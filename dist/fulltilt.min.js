const t=Math.PI,e=t/2,s=2*t,n=t/180,a=180/t,i=e,r=t,o=s/3,c=-e;function h(){const t=y.instance,[e,s]=u(screen.orientation),a=s?-e:e;t.screenOrientationAngle=g(screen.orientation.angle+a,360)*n,t.screenOrientationType=screen.orientation.type}const l=t=>{const e=y.instance;e.sensors.orientation.data=t,e.sensors.orientation.callbacks.forEach((t=>t()))},m=t=>{const e=y.instance;e.sensors.motion.data=t,e.sensors.motion.callbacks.forEach((t=>t()))};function u(t){const e=navigator.userAgentData?.platform||navigator?.platform||"unknown";let s=0,n="iPad"===e||"MacIntel"===e&&navigator.maxTouchPoints>0;switch(t.type){case"portrait-primary":90===t.angle&&(s=90);break;case"portrait-secondary":270===t.angle&&(s=90);break;case"landscape-primary":0===t.angle&&n&&(s=270);break;case"landscape-secondary":180===t.angle&&n&&(s=270)}return[s,n]}class y{static _instance;screenOrientationAngle;screenOrientationType;sensors;constructor(){const[t,e]=u(screen.orientation),s=e?360-t:t;if(this.screenOrientationAngle=g(screen.orientation.angle+s,360)*n,this.screenOrientationType=screen.orientation.type,this.sensors={orientation:{active:!1,callbacks:[],data:void 0},motion:{active:!1,callbacks:[],data:void 0}},!window.isSecureContext)throw new Error("Device Orientation and Motion sensors are only available in a secure context.");window.screen.orientation.addEventListener("change",h,!1)}static get instance(){return this._instance||(this._instance=new y),this._instance}}async function d(t){const e=y.instance,s=new v(t);s.start();try{await async function(t,e=!1){return new Promise(((s,n)=>{const a=i=>{setTimeout((()=>{t?.data&&t.data.alpha||!e?s(null):i>=20?n():a(++i)}),50)};a(0)}))}(e.sensors.orientation,t.requireLiveData||!1)}catch(t){return s.stop(),console.error("FullTilt: DeviceOrientation is not supported",t),null}return s}async function w(t){const e=y.instance,s=new x;s.start();try{await async function(t,e=!1){return new Promise(((s,n)=>{const a=i=>{setTimeout((()=>{!t?.data||!t.data.acceleration?.x&&e?i>=20?n():a(++i):s(null)}),50)};a(0)}))}(e.sensors.motion,t.requireLiveData||!1)}catch(t){return s.stop(),console.error("FullTilt: DeviceMotion is not supported",t),null}return s}async function p(t){const e={};try{t&&"orientation"!==t||("function"!=typeof DeviceOrientationEvent.requestPermission?e.orientation="granted":e.orientation=await DeviceOrientationEvent.requestPermission())}catch(t){"NotAllowedError"===t.name&&(e.orientation="prompt")}try{t&&"motion"!==t||"function"!=typeof DeviceMotionEvent.requestPermission||("function"!=typeof DeviceMotionEvent.requestPermission?e.motion="granted":e.motion=await DeviceMotionEvent.requestPermission())}catch(t){"NotAllowedError"===t.name&&(e.motion="prompt")}return e}function g(t,e){for(;t<e;)t+=e;return t%e}class x{state=y.instance;constructor(){}start(t){t&&"function"==typeof t&&this.state.sensors.motion.callbacks.push(t),this.state.sensors.motion.active||(window.addEventListener("devicemotion",m,!1),this.state.sensors.motion.active=!0)}stop(){this.state.sensors.motion.active&&(window.removeEventListener("devicemotion",m,!1),this.state.sensors.motion.active=!1)}listen(t){t&&"function"==typeof t&&this.start(t)}getScreenAdjustedAcceleration(){const t={x:this.state.sensors.motion.data?.acceleration?.x||0,y:this.state.sensors.motion.data?.acceleration?.y||0,z:this.state.sensors.motion.data?.acceleration?.z||0},e={x:0,y:0,z:0};switch(this.state.screenOrientationAngle){case i:e.x=-(t.y||0),e.y=t.x||0;break;case r:e.x=-(t.x||0),e.y=-(t.y||0);break;case o:case c:e.x=t.y||0,e.y=-(t.x||0);break;default:e.x=t.x||0,e.y=t.y||0}return e.z=t.z||0,e}getScreenAdjustedAccelerationIncludingGravity(){const t={x:this.state.sensors.motion.data?.accelerationIncludingGravity?.x||0,y:this.state.sensors.motion.data?.accelerationIncludingGravity?.y||0,z:this.state.sensors.motion.data?.accelerationIncludingGravity?.z||0},e={x:0,y:0,z:0};switch(screen.orientation.angle){case i:e.x=-t.y,e.y=t.x;break;case r:e.x=-t.x,e.y=-t.y;break;case o:case c:e.x=t.y,e.y=-t.x;break;default:e.x=t.x,e.y=t.y}return e.z=t.z,e}getScreenAdjustedRotationRate(){const t={alpha:this.state.sensors.motion.data?.rotationRate?.alpha||0,beta:this.state.sensors.motion.data?.rotationRate?.beta||0,gamma:this.state.sensors.motion.data?.rotationRate?.gamma||0},e={alpha:0,beta:0,gamma:0};switch(screen.orientation.angle){case i:e.beta=-(t.gamma||0),e.gamma=t.beta||0;break;case r:e.beta=-(t.beta||0),e.gamma=-(t.gamma||0);break;case o:case c:e.beta=t.gamma||0,e.gamma=-(t.beta||0);break;default:e.beta=t.beta||0,e.gamma=t.gamma||0}return e.alpha=t.alpha||0,e}getLastRawEventData(){return this.state.sensors.motion.data||{}}}class v{state=y.instance;alphaOffsetScreen=0;alphaOffsetDevice;tries=0;maxTries=200;successCount=0;successThreshold=30;constructor(t){if("world"===t?.type){const t=e=>{(!e.absolute&&e.webkitCompassAccuracy&&+e.webkitCompassAccuracy>=0&&+e.webkitCompassAccuracy<50&&(this.alphaOffsetDevice=new M(e.webkitCompassHeading,0,0),this.alphaOffsetDevice.rotateZ(this.state.screenOrientationAngle),this.alphaOffsetScreen=this.state.screenOrientationAngle,++this.successCount>=this.successThreshold)||++this.tries>=this.maxTries)&&window.removeEventListener("deviceorientation",t,!1)};window.addEventListener("deviceorientation",t,!1),document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&window.addEventListener("deviceorientation",t,!1)}),!1)}else{const t=e=>{(null!==e.alpha&&(this.alphaOffsetDevice=new M(e.alpha,0,0),this.alphaOffsetDevice.rotateZ(-screen.orientation.angle),++this.successCount>=this.successThreshold)||++this.tries>=this.maxTries)&&window.removeEventListener("deviceorientation",t,!1)};window.addEventListener("deviceorientation",t,!1)}}start(t){t&&"function"==typeof t&&this.state.sensors.orientation.callbacks.push(t),this.state.sensors.orientation.active||(void 0!==window.ondeviceorientationabsolute?window.addEventListener("deviceorientationabsolute",l,!1):window.addEventListener("deviceorientation",l,!1),this.state.sensors.orientation.active=!0)}stop(){this.state.sensors.orientation.active&&(void 0!==window.ondeviceorientationabsolute?window.removeEventListener("deviceorientationabsolute",l,!1):window.removeEventListener("deviceorientation",l,!1),this.state.sensors.orientation.active=!1)}listen(t){this.start(t)}getFixedFrameQuaternion(){const t=new f,e=this.getFixedFrameEuler();return t.setFromEuler(e),t}getScreenAdjustedQuaternion(){const t=this.getFixedFrameQuaternion();return t.rotateZ(-this.state.screenOrientationAngle),t}getFixedFrameMatrix(){const t=this.getFixedFrameEuler(),e=new A;return e.setFromEuler(t),e}getScreenAdjustedMatrix(){const t=this.getFixedFrameMatrix();return t.rotateZ(s-this.state.screenOrientationAngle),t}getFixedFrameEuler(){const t=new M,e=new A,s=this.state.sensors.orientation.data||{alpha:0,beta:0,gamma:0};let n=s.alpha||0;return this.alphaOffsetDevice&&(e.setFromEuler(this.alphaOffsetDevice),e.rotateZ(-this.alphaOffsetScreen),t.setFromRotationMatrix(e),t.alpha<0&&(t.alpha+=360),t.alpha%=360,n-=t.alpha),t.set(n,s.beta||0,s.gamma||0)}getScreenAdjustedEuler(){const t=new M,e=this.getScreenAdjustedMatrix();return t.setFromRotationMatrix(e),t}get lastRawEventData(){return this.state.sensors.orientation.data||{}}get screenOrientationAngle(){return this.state.screenOrientationAngle*a}get screenOrientationType(){return this.state.screenOrientationType}}class M{alpha;beta;gamma;constructor(t=0,e=0,s=0){this.alpha=t,this.beta=e,this.gamma=s}set(t,e,s){return this.alpha=t,this.beta=e,this.gamma=s,this}copy(t){return this.alpha=t.alpha,this.beta=t.beta,this.gamma=t.gamma,this}setFromRotationMatrix(n){const i=n.elements;let r,o,c;return i[8]>0?(r=Math.atan2(-i[1],i[4]),o=Math.asin(i[7]),c=Math.atan2(-i[6],i[8])):i[8]<0?(r=Math.atan2(i[1],-i[4]),o=-Math.asin(i[7]),o+=o>=0?-t:t,c=Math.atan2(i[6],-i[8])):i[6]>0?(r=Math.atan2(-i[1],i[4]),o=Math.asin(i[7]),c=-e):i[6]<0?(r=Math.atan2(i[1],-i[4]),o=-Math.asin(i[7]),o+=o>=0?-t:t,c=-e):(r=Math.atan2(i[3],i[0]),o=i[7]>0?e:-e,c=0),r<0&&(r+=s),r*=a,o*=a,c*=a,this.set(r,o,c),this}setFromQuaternion(n){let i,r,o;const c=n.w*n.w,h=n.x*n.x,l=n.y*n.y,m=n.z*n.z,u=c+h+l+m,y=n.w*n.x+n.y*n.z;if(y>.499999*u)i=2*Math.atan2(n.y,n.w),r=e,o=0;else if(y<-.499999*u)i=-2*Math.atan2(n.y,n.w),r=-e,o=0;else{const e=c-h+l-m,s=2*(n.w*n.z-n.x*n.y),a=c-h-l+m,d=2*(n.w*n.y-n.x*n.z);a>0?(i=Math.atan2(s,e),r=Math.asin(2*y/u),o=Math.atan2(d,a)):(i=Math.atan2(-s,-e),r=-Math.asin(2*y/u),r+=r<0?t:-t,o=Math.atan2(-d,-a))}return i<0&&(i+=s),i*=a,r*=a,o*=a,this.set(i,r,o),this}rotateX(t){return this.rotateByAxisAngle(this,[1,0,0],t)}rotateY(t){return this.rotateByAxisAngle(this,[0,1,0],t)}rotateZ(t){return this.rotateByAxisAngle(this,[0,0,1],t)}rotateByAxisAngle(t,e,s){const n=(new A).setFromEuler(t).rotateByAxisAngle(void 0,e,s);return t.setFromRotationMatrix(n),t}}class f{x;y;z;w;constructor(t=0,e=0,s=0,n=0){this.x=t,this.y=e,this.z=s,this.w=n}set(t=0,e=0,s=0,n=0){return this.x=t,this.y=e,this.z=s,this.w=n,this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}setFromEuler(t){let e,s,a,i,r,o,c,h,l;return a=((t=t||new M).alpha||0)*n/2,e=(t.beta||0)*n/2,s=(t.gamma||0)*n/2,i=Math.cos(e),r=Math.cos(s),o=Math.cos(a),c=Math.sin(e),h=Math.sin(s),l=Math.sin(a),this.set(c*r*o-i*h*l,i*h*o+c*r*l,i*r*l+c*h*o,i*r*o-c*h*l),this.normalize(),this}setFromRotationMatrix(t){const e=t.elements;return this.set(.5*Math.sqrt(1+e[0]-e[4]-e[8])*Math.sign(e[7]-e[5]),.5*Math.sqrt(1-e[0]+e[4]-e[8])*Math.sign(e[2]-e[6]),.5*Math.sqrt(1-e[0]-e[4]+e[8])*Math.sign(e[3]-e[1]),.5*Math.sqrt(1+e[0]+e[4]+e[8])),this}multiply(t){const e=this.multiplyQuaternions(this,t);return this.copy(e),this}rotateX(t){const e=this.rotateByAxisAngle(this,[1,0,0],t);return this.copy(e),this}rotateY(t){const e=this.rotateByAxisAngle(this,[0,1,0],t);return this.copy(e),this}rotateZ(t){const e=this.rotateByAxisAngle(this,[0,0,1],t);return this.copy(e),this}multiplyQuaternions(t,e){const s=new f,n=t.x,a=t.y,i=t.z,r=t.w,o=e.x,c=e.y,h=e.z,l=e.w;return s.set(n*l+r*o+a*h-i*c,a*l+r*c+i*o-n*h,i*l+r*h+n*c-a*o,r*l-n*o-a*c-i*h),s}normalize(t){t||(t=this);var e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w);return 0===e?(t.x=0,t.y=0,t.z=0,t.w=1):(e=1/e,t.x*=e,t.y*=e,t.z*=e,t.w*=e),t}rotateByAxisAngle(t,e,s){const n=new f,a=(s||0)/2,i=Math.sin(a);n.set((e[0]||0)*i,(e[1]||0)*i,(e[2]||0)*i,Math.cos(a));const r=this.multiplyQuaternions(t,n);return this.normalize(r)}}class A{elements=new Float32Array(9);constructor(t=1,e=0,s=0,n=0,a=1,i=0,r=0,o=0,c=1){this.set(t,e,s,n,a,i,r,o,c)}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}set(t=1,e=0,s=0,n=0,a=1,i=0,r=0,o=0,c=1){return this.elements[0]=t,this.elements[1]=e,this.elements[2]=s,this.elements[3]=n,this.elements[4]=a,this.elements[5]=i,this.elements[6]=r,this.elements[7]=o,this.elements[8]=c,this}copy(t){return this.elements[0]=t.elements[0],this.elements[1]=t.elements[1],this.elements[2]=t.elements[2],this.elements[3]=t.elements[3],this.elements[4]=t.elements[4],this.elements[5]=t.elements[5],this.elements[6]=t.elements[6],this.elements[7]=t.elements[7],this.elements[8]=t.elements[8],this}setFromEuler(t){const e=((t=t||{}).alpha||0)*n,s=(t.beta||0)*n,a=(t.gamma||0)*n,i=Math.cos(s),r=Math.cos(a),o=Math.cos(e),c=Math.sin(s),h=Math.sin(a),l=Math.sin(e);return this.set(o*r-l*c*h,-i*l,r*l*c+o*h,r*l+o*c*h,o*i,l*h-o*r*c,-i*h,c,i*r),this.normalize(),this}setFromQuaternion(t){const e=t.w*t.w,s=t.x*t.x,n=t.y*t.y,a=t.z*t.z;return this.set(e+s-n-a,2*(t.x*t.y-t.w*t.z),2*(t.x*t.z+t.w*t.y),2*(t.x*t.y+t.w*t.z),e-s+n-a,2*(t.y*t.z-t.w*t.x),2*(t.x*t.z-t.w*t.y),2*(t.y*t.z+t.w*t.x),e-s-n+a),this}multiply(t){const e=this.multiplyMatrices(this,t);return this.copy(e),this}rotateX(t){const e=this.rotateByAxisAngle(this,[1,0,0],t);return this.copy(e),this}rotateY(t){const e=this.rotateByAxisAngle(this,[0,1,0],t);return this.copy(e),this}rotateZ(t){const e=this.rotateByAxisAngle(this,[0,0,1],t);return this.copy(e),this}multiplyMatrices(t,e){const s=new A,n=t.elements,a=e.elements;return s.set(n[0]*a[0]+n[1]*a[3]+n[2]*a[6],n[0]*a[1]+n[1]*a[4]+n[2]*a[7],n[0]*a[2]+n[1]*a[5]+n[2]*a[8],n[3]*a[0]+n[4]*a[3]+n[5]*a[6],n[3]*a[1]+n[4]*a[4]+n[5]*a[7],n[3]*a[2]+n[4]*a[5]+n[5]*a[8],n[6]*a[0]+n[7]*a[3]+n[8]*a[6],n[6]*a[1]+n[7]*a[4]+n[8]*a[7],n[6]*a[2]+n[7]*a[5]+n[8]*a[8]),s}normalize(t=this){const e=t.elements,s=e[0]*e[4]*e[8]-e[0]*e[5]*e[7]-e[1]*e[3]*e[8]+e[1]*e[5]*e[6]+e[2]*e[3]*e[7]-e[2]*e[4]*e[6];return e[0]/=s,e[1]/=s,e[2]/=s,e[3]/=s,e[4]/=s,e[5]/=s,e[6]/=s,e[7]/=s,e[8]/=s,t.elements=e,t}rotateByAxisAngle(t=this,e,s){let n;const a=new A;let i,r,o=!1;return a.identity(),i=Math.sin(s),r=Math.cos(s),1===e[0]&&0===e[1]&&0===e[2]?(o=!0,a.elements[4]=r,a.elements[5]=-i,a.elements[7]=i,a.elements[8]=r):1===e[1]&&0===e[0]&&0===e[2]?(o=!0,a.elements[0]=r,a.elements[2]=i,a.elements[6]=-i,a.elements[8]=r):1===e[2]&&0===e[0]&&0===e[1]&&(o=!0,a.elements[0]=r,a.elements[1]=-i,a.elements[3]=i,a.elements[4]=r),o?(n=this.multiplyMatrices(t,a),n=this.normalize(n)):n=t,n}}export{x as DeviceMotion,v as DeviceOrientation,M as Euler,f as Quaternion,A as RotationMatrix,w as getDeviceMotion,d as getDeviceOrientation,p as requestPermission};
//# sourceMappingURL=fulltilt.min.js.map
